#!/usr/bin/env node
import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'node:fs';
import path from 'node:path';

const rootDir = process.cwd();
const baselinePath = path.join(rootDir, 'database_baseline', 'BASELINE_SCHEMA_TABLES_ONLY.sql');
const outputDir = path.join(rootDir, 'src', 'types');
const outputPath = path.join(outputDir, 'database.ts');

const typeMap = (dataType) => {
  const normalized = dataType.toLowerCase();
  if (normalized.endsWith('[]')) {
    const base = normalized.replace(/\[\]$/, '');
    return `${typeMap(base)}[]`;
  }

  if (/^uuid$/.test(normalized)) return 'string';
  if (/^text$/.test(normalized)) return 'string';
  if (/^varchar/.test(normalized)) return 'string';
  if (/^character varying/.test(normalized)) return 'string';
  if (/^timestamp/.test(normalized) || /^timestamptz$/.test(normalized) || /^time/.test(normalized) || /^date$/.test(normalized)) return 'string';
  if (/^jsonb?$/.test(normalized)) return 'Json';
  if (/^numeric|^decimal/.test(normalized)) return 'string | number';
  if (/^double precision$/.test(normalized)) return 'number';
  if (/^real$/.test(normalized)) return 'number';
  if (/^integer$/.test(normalized) || /^int\d*$/.test(normalized)) return 'number';
  if (/^bigint$/.test(normalized)) return 'string';
  if (/^boolean$/.test(normalized)) return 'boolean';
  if (/^smallint$/.test(normalized)) return 'number';
  if (/^bytea$/.test(normalized)) return 'string';
  if (/^money$/.test(normalized)) return 'string';
  return 'unknown';
};

const parseTables = (sql) => {
  const tables = new Map();
  const tableRegex = /CREATE\s+TABLE\s+IF\s+NOT\s+EXISTS\s+public\.([a-zA-Z0-9_]+)\s*\(([\s\S]*?)\);/gi;
  let tableMatch;

  while ((tableMatch = tableRegex.exec(sql)) !== null) {
    const tableName = tableMatch[1];
    const tableBody = tableMatch[2];
    const lines = tableBody.split('\n').map((line) => line.trim()).filter(Boolean);
    const columns = [];

    for (const rawLine of lines) {
      const line = rawLine.replace(/,$/, '');
      if (/^(CONSTRAINT|PRIMARY|UNIQUE|FOREIGN|CHECK)/i.test(line)) continue;
      if (line.startsWith('--')) continue;

      const parts = line.split(/\s+/);
      const columnName = parts.shift().replace(/"/g, '');
      if (!columnName) continue;

      const typeTokens = [];
      while (parts.length > 0 && !/^(NOT|DEFAULT|PRIMARY|UNIQUE|REFERENCES|CHECK|CONSTRAINT)$/i.test(parts[0])) {
        typeTokens.push(parts.shift());
      }

      const dataType = typeTokens.join(' ');
      const notNull = /NOT\s+NULL/i.test(line);
      const hasDefault = /DEFAULT/i.test(line);
      columns.push({ columnName, dataType, notNull, hasDefault });
    }

    tables.set(tableName, columns);
  }

  return tables;
};

const parseEnums = (sql) => {
  const enums = new Map();
  const enumRegex = /CREATE\s+TYPE\s+IF\s+NOT\s+EXISTS\s+public\.([a-zA-Z0-9_]+)\s+AS\s+ENUM\s*\(([\s\S]*?)\);/gi;
  let enumMatch;

  while ((enumMatch = enumRegex.exec(sql)) !== null) {
    const enumName = enumMatch[1];
    const valuesBody = enumMatch[2];
    const values = valuesBody
      .split(',')
      .map((value) => value.trim().replace(/^'|'$/g, ''))
      .filter(Boolean);
    enums.set(enumName, values);
  }

  return enums;
};

const generateTypes = (tables, enums) => {
  const tableEntries = Array.from(tables.entries())
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([tableName, columns]) => {
      const rowLines = columns
        .map(({ columnName, dataType }) => `        ${JSON.stringify(columnName)}: ${typeMap(dataType)};`)
        .join('\n');

      const insertLines = columns
        .map(({ columnName, dataType, notNull, hasDefault }) => {
          const optional = !notNull || hasDefault ? '?' : '';
          return `        ${JSON.stringify(columnName)}${optional}: ${typeMap(dataType)};`;
        })
        .join('\n');

      const updateLines = columns
        .map(({ columnName, dataType }) => `        ${JSON.stringify(columnName)}?: ${typeMap(dataType)};`)
        .join('\n');

      return `      ${JSON.stringify(tableName)}: {
        Row: {
${rowLines}
        };
        Insert: {
${insertLines}
        };
        Update: {
${updateLines}
        };
        Relationships: [];
      }`;
    })
    .join(',\n');

  const enumEntries = Array.from(enums.entries())
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([enumName, values]) => `      ${JSON.stringify(enumName)}: ${values.map((value) => JSON.stringify(value)).join(' | ')};`)
    .join('\n');

  return `/**
 * Auto-generated by Supabase types generator script.
 * Do not edit manually – run \`npm run supabase:types\` instead.
 */

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[];

export type Database = {
  public: {
    Tables: {
${tableEntries}
    };
    Views: Record<string, never>;
    Functions: Record<string, never>;
    Enums: {
${enumEntries || '      // no enums detected'}
    };
    CompositeTypes: Record<string, never>;
  };
};
`;
};

const main = () => {
  const sql = readFileSync(baselinePath, 'utf8');
  const tables = parseTables(sql);
  const enums = parseEnums(sql);
  const types = generateTypes(tables, enums);

  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  writeFileSync(outputPath, types, 'utf8');
  console.log(`✨ Generated Supabase types at ${path.relative(rootDir, outputPath)}`);
};

main();
